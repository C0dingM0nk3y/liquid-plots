---
title: "LiquidPlots"
output:
  html_document:
    df_print: paged
    code_folding: hide
---

```{css, echo=FALSE}
.box{
  font-size: 75%;
}
blockquote{
  font-size: 90%;
}
```

Author: C0dingM0nk3y    [>>GitHub link<<](https://github.com/C0dingM0nk3y)

---

# {.tabset}

[] Add descriptions \ 
[x] Change order of downloads \ 
[x] Improve coin filter \ 
[] Wrap ref data into zip file \
[x] Claim from start \
[] Chang plot var names so to erase previous data

General options: \
```{r options, code_folding="none"}
#RUN OPTIONS
run_api = TRUE #toggle TRUE/FALSE to skip some parts of this script
  subset_download = TRUE
  subset_analysis = TRUE
  subset_list <- c("BTC|ETH|RUNE|STG") #can be used to restrict analysis to a specific sibset of poolNames/Coins. Use REGEX syntax.
run_analysis = TRUE
run_plots = TRUE

refCoin = "USDT" #reference coin to express prices
```

Plot options: \
```{r plot-options}
setStopLoss <- 0.005 #set desired stop loss for plots

allow_refData = FALSE
```


```{r init, include=FALSE}
#If not installed yet, install pacman package manager by "uncommenting" the line below

#install.packages("pacman") #this is only required on first run.

source("_SCRIPTS/init_externalLibs.R") 
#If not installed yet, pacman will download and install all required packages on the first run of the script.

source("_SCRIPTS/init_functions.R")
source("_SCRIPTS/init_plots.R")
source("_SCRIPTS/init_dirs.R")
```

---

## 1. DATA

##### API address and credentials
> First time istructions:\
USER_KEY is imported from local file: *"/credentials.txt"*\
Recover data from your Binance account, then save into [root dir]: \
use format below, and name the file as *'credentials.txt'*:\
<p style="margin-left: 40px">
key;YOUR-BINANCE-API-KEY\
prKey;YOUR-PRIVATE-KEY\
</p>

```{r credentials, results = "asis"}
#API address
API_root <- "https://api.binance.com" 
  
myPrivatePath <- "D:/Clouds/Dropbox/Everywhere/PROJECTS/PiggyBank/Binance/liquid-plot_myCredential.txt" #TEMP

#Import credentials
#keys <- read.csv2("credentials.txt", col.names = c("Type", "Key"), header = F)
keys_import <- read.csv2(myPrivatePath, col.names = c("Type", "Key"), header = F)

key_public <- keys_import[1,"Key", drop=T]
key_private <- keys_import[2,"Key", drop=T]
rm("keys_import")

#USER FEEDBACK
if(key_public=="YOUR-BINANCE-API-KEY"){
  stop("STOP: add your Binance API credential to /credential.txt (; separated)")}
```

Data recovered from [`r API_root`] using the following credentials:\
<p style="margin-left: 40px">
**PUBLIC key**: `r ifelse(run_api, key_public, "SKIPPED")`\
**PRIVATE key**: [see "/credentials.txt"]
</p>

---

##### DOWNLOAD Binance Data [API]
for info, refer to: https://binance-docs.github.io/apidocs/spot/en/#change-log\
<p style="margin-left: 40px">
Download to: `r dir.IN`\
</p>

***
##### GET: PRICES
Latest SPOT prices from Binance. Used for HODL vs. LP calculation\

```{r price-api, results="hold", echo=FALSE}
# DOWNLOAD PRICES
price.j.path <- paste0(dir.IN, "API_price.json")
price.csv.path <- paste0(dir.IN, "API_price_unpacked.csv")

if(run_api){
  API_query <- "/api/v3/ticker/price"
  
  price.j <- BINANCE.GET(API_root, "/api/v3/ticker/price", output = "both") #download Binance latest Prices
  
  request <- price.j[[1]] 
  json <- price.j[[2]]
  
  write_json(json, price.j.path, auto_unbox=TRUE) #export
  cat("\t-> saved to: ", price.j.path, "\n")
  
  price.df <- fromJSON(price.j.path, simplifyVector = TRUE,
                     flatten = TRUE) #automatically UN-Nest nested columns
  
  #append price datastamp (from file last edit)
  timestamp <- request$date %>% as.POSIXct(tz="UTC")
  price.df[,"timestamp_UTC"] <- as.character(timestamp)
  
  write.csv2(price.df, file = price.csv.path, row.names = F)
  cat(sprintf("\tCONVERTED TO .CSV\t-> export to: %s (%s rows)\n", price.csv.path, nrow(price.df)))
}else{
  price.df <- read.csv2(price.csv.path)
  cat("Running Offline. Last available data from file:\n")
  cat("\t", price.csv.path)
}
```


***
##### GET: CURRENT POOLS
Latest data about currently active pool and their Coin composition. 

```{r liquidity-now, results="hold"}
if(run_api){
  # DOWNLOAD
  liq.j <- BINANCE.GET(API_root, "/sapi/v1/bswap/liquidity", timestamp = TRUE, sign = TRUE) 
  
  # JSON EXPORT
  liq.j.path <- paste0(dir.IN, "API_liq.json")
  write_json(liq.j, liq.j.path, auto_unbox=TRUE) # export JSON file to /DOWNLOADS
  cat(sprintf("\t-> export to: %s\n", liq.j.path))
  
  # TABLE INTERPRETATION
  #> this function does not ONLY unpack liquidity data, but it also unpivot the table, to make it readable
  liq.df <- liquidity.tableInterpreter(liq.j.path) 

  if(subset_download){
    message("FILTER on DOWNLOAD: only selected pools are downloaded")            #TEMP
    liq.df %<>% subset(grepl(subset_list, liq.df$poolName))}  #TEMP
 
  liq.df.path <- paste0(dir.IN, "API_liquidity_unpacked.csv")
  write.csv2(liq.df, liq.df.path, row.names = F)
  cat(sprintf("\tUNPACKED INTO .CSV\t-> export to: %s (%s rows)\n", liq.df.path, nrow(liq.df)))
  
}else{
  cat(sprintf("Running Offline. Last pool data were imported from file:\n\t%s\n", paste0(dir.IN,"API_liquidity_unpacked.csv")))
  
  liq.df <- read.csv2(paste0(dir.IN,"API_liquidity_unpacked.csv"))}

if(subset_analysis){
  message("FILTER on CALC: only selected pools are shown")  
  tot_pools <- nrow(liq.df)
  liq.df %<>% subset(grepl(subset_list, liq.df$poolName))  
  cat(sprintf("\tAvailable: %s\tDisplayed: %s", tot_pools, nrow(liq.df)))
  }  
```

```{r price-matrix, include=FALSE}
# unique coins (to fetch prices)
coinList <- unique(liq.df$poolName) %>% 
  str_split("/") %>% unlist() %>% 
  c("BNB") %>% #add BNB, as this will be needed for extraRewards calculations
  unique()

# EXTRACTS PRICES for the relevant coins
priceMatrix <- data.frame()

for (c in coinList){
  priceMatrix[c,refCoin] <- getPrice(price.df, c, refCoin = refCoin) %>% as.numeric()}

priceMatrix[, "timestamp"] <- price.df[1,"timestamp_UTC"]
```

```{r active-calc, echo=FALSE}
#> Append current prices and calculate values
liq.df[,"Date_UTC"] <- msec_to_datetime(liq.df$updateTime)

#> # Assign price value to each coin
liq.df[,"Price"] <- priceMatrix[liq.df$Coin, refCoin] #recover price from priceMatrix
liq.df[,"Value"] <- with(liq.df, share.asset*Price) %>% round(8)
liq.df[,"Currency"] <- refCoin

# perfrom all CALCULATION in separate FUNC
active.DF <- activePools.Calc(liq.df)

# EXPORT
write.csv2(active.DF, paste0(dir.TABLES, "ActivePools.csv"), row.names = F)

# FORMAT to PRINT
active.DF %>% 
  subset(select = c("poolName", "poolId", "share.Amount", "Value_TOT", "Currency", "Date_UTC")) %>% #select useful col.
  unique() %>% #filters out duplicated entries (2x for each pool)
  kable(align= "c", digits = 2, caption = "<b>Currently ACTIVE Pools</b>") %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F) %>%
  column_spec(c(1), bold=T) 
```

***

##### GET: SINGLE POOLS {.tabset}

<p style="margin-left: 40px">
Download to: `r dir.IN.single`\ 
</p>

Found `r ifelse(run_api, length(unique(liq.df$poolName)), "X")` pools:\
_Recovering single pool data (single API calls)._

```{r loop-api, results='asis'}
# Useful lists
poolId_list <- unique(liq.df$poolId) #all unique poolId
poolNames_list <- unique(liq.df$poolName) #unique poolNames

if(run_api){
  
  for (x in 1:length(poolId_list)){
    #POOL-NAME
    id <- poolId_list[x]
    pName <- poolNames_list[x]
    
    cat(sprintf("###### %s \n", pName)) # Tabs header
    cat("<div>") 
    source("_SCRIPTS/script_SINGLE_v0.R") #download only
    cat("</div>") 
    }
  }else{
  #  ops.table.path
  #ops.j <- read.csv2(ops.table.path)
  #cat("Running Offline. Last available data from file:\n")
  #cat("\t", ops.table.path)
}

```


## 2. ANALYIS 

Analyze pool positions according to latest prices. \
_All prices are in **`r refCoin`**_

`r priceMatrix`

Latest prices timestamp: **`r price.df[1,"timestamp_UTC", drop= TRUE]`**\ 

***

Plotting parameters:\

setStopLoss=`r setStopLoss` \
allow_refData=`r allow_refData` \

### Single Pools {.tabset}
```{r loop-plots, results='asis', fig.align='center', fig.height=6, fig.width=10}
# Useful lists
poolId_list <- unique(liq.df$poolId) #all unique poolId
poolNames_list <- unique(liq.df$poolName) #unique poolNames
  
for (x in 1:length(poolId_list)){
  #POOL-NAME
  id <- poolId_list[x]
  pName <- poolNames_list[x]
  
  cat(sprintf("#### %s\n", pName)) # Tabs header
  
    cat("<div> \n") #Separate block for the TAB function
    cat(sprintf("<p>Pool: %s (poolId=%s)</p>\n", pName, id))
    
    # DATA ANALYIS
    source("_SCRIPTS/script_CALC_v0.R") # all CALC
    source("_SCRIPTS/script_PLOT_v0.R") # all PLOTS
    
    # PLOTS
    cat("<div>\n") #Separate block for the TAB function
    print(pw) #main figure
    cat("</div>\n")
  
    # Link to Binance pool
    cat(sprintf('<p>Direct Link to Binance Pool: <a href="https://www.binance.com/en/swap/liquidity?poolId=%s">(%s)</a></p>\n', id, poolName))
    
    cat("<div> \n") 
    cat("##### DATA-TABLES, sources:<br>\n") # Tabs header
    cat(sprintf('Pool History: <a href="%s">%s</a><br>', pool.history.path, pool.history.path))
    cat(sprintf('Pool Claims: <a href="%s">%s</a> <br>', claim.table.path, claim.table.path))
    cat("</div> \n") 
    
    #cat("###### Pool Operations<br>\n") 
    #pool_LAST
    #cat("###### Pool Claims<br>\n") 
    #claim_CALC
    #cat("###### Pool Endpoints<br>\n")
    #end_DF
    #cat("</div> \n") 
  }
```



##### Database Update

```{r}
#to be implemented
```

***

## 3. POOL OVERVIEW

TO IMPLEMENT\
[x] automated plotting\
[x] link to Binance pool\
[ ] Summary table (Analysis part)\
[ ] Subgroups\
                

Overview of latest pools [currently active]

```{r active-print}

 
# USER PLOT
# Print current Pools
active.DF %>% subset(select = c("poolName", "poolId", "Date_UTC", 
                                "Qnt1", "Coin1", "Qnt2", "Coin2", 
                                "Value_TOT", "Currency")) %>% #select useful col.
  kable(digits = c(2,2,2,4,4,4,4,2,2), align= c("c","c","r","r","l","r","l","r","l"), 
        caption = "<b>Currently ACTIVE Pools</b>") %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), full_width = F) %>%
  column_spec(c(4,5), color="darkblue") %>% 
  column_spec(c(1,8,9), bold=T) 
```


```{r overview, include=FALSE, eval=FALSE}
poolId_list_original <- poolId_list

summary.DF <- data.frame(active.DF, row.names = active.DF$poolId) 

for (i in poolId_list_original){
  pool.history.path <- paste0(dir.TABLES.single,i,"_pool.History.csv") #includes OPS and SNAPS
  #claim.table.path <- paste0(dir.TABLES.single,i,"_claim.csv")
  
  pool_H <- read.csv2(pool.history.path) #%>% as.tibble()
  pool_H[,"Date_UTC"] %<>% as.POSIXct(tz="UTC")
  #claim_H <- read.csv2(claim.table.path) #REPLACE WITH HIST FILE
  #claim_H[,"Date_UTC"] %<>% as.POSIXct(tz="UTC")

  start_DF <- pool_H %>% 
    subset(operation=="ADD") %>% 
    tail(1)# find last ADD
  
  summary.DF[as.character(i), "startDate"] <- start_DF[1, "Date_UTC", drop=T]
}

summary.DF <- summary.DF[order(summary.DF$Value_TOT, decreasing = T), ]
```

